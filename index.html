<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Cube Toggle Game</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #1a1a1a;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        #container {
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 14px;
            z-index: 100;
        }
        #resetButton {
            position: absolute;
            top: 20px;
            right: 20px;
            padding: 10px 20px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            z-index: 100;
        }
        #resetButton:hover {
            background: #45a049;
        }
    </style>
</head>
<body>
    <div id="info">
        <div>Click squares to toggle them and their diagonal neighbors</div>
        <div>Drag to rotate the cube</div>
    </div>
    <button id="resetButton" onclick="resetCube()">Reset Cube</button>
    <div id="container"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer, cube, raycaster, mouse;
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        
        // Cube state: 6 faces, each with 9 squares (3x3 grid)
        // Faces: front, back, right, left, top, bottom
        let cubeState = {
            front: Array(9).fill(false),   // false = white, true = black
            back: Array(9).fill(false),
            right: Array(9).fill(false),
            left: Array(9).fill(false),
            top: Array(9).fill(false),
            bottom: Array(9).fill(false)
        };

        // Face names array for easy iteration
        const faceNames = ['front', 'back', 'right', 'left', 'top', 'bottom'];
        
        // Store face meshes for raycasting
        let faceMeshes = {};
        let squareMeshes = {};

        function init() {
            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a4d2e); // Dark green background
            
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(5, 5, 5);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('container').appendChild(renderer.domElement);

            // Raycaster for mouse interaction
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            // Create cube
            createCube();

            // Event listeners
            renderer.domElement.addEventListener('mousedown', onMouseDown);
            renderer.domElement.addEventListener('mousemove', onMouseMove);
            renderer.domElement.addEventListener('mouseup', onMouseUp);
            renderer.domElement.addEventListener('click', onMouseClick);
            window.addEventListener('resize', onWindowResize);

            // Animation loop
            animate();
        }

        function createCube() {
            cube = new THREE.Group();
            
            // Cube faces configuration
            const faceConfigs = [
                { name: 'front', position: [0, 0, 1.5], rotation: [0, 0, 0] },
                { name: 'back', position: [0, 0, -1.5], rotation: [0, Math.PI, 0] },
                { name: 'right', position: [1.5, 0, 0], rotation: [0, Math.PI/2, 0] },
                { name: 'left', position: [-1.5, 0, 0], rotation: [0, -Math.PI/2, 0] },
                { name: 'top', position: [0, 1.5, 0], rotation: [-Math.PI/2, 0, 0] },
                { name: 'bottom', position: [0, -1.5, 0], rotation: [Math.PI/2, 0, 0] }
            ];

            faceConfigs.forEach(config => {
                const face = createFace(config.name);
                face.position.set(...config.position);
                face.rotation.set(...config.rotation);
                cube.add(face);
            });

            scene.add(cube);
        }

        function createFace(faceName) {
            const faceGroup = new THREE.Group();
            faceMeshes[faceName] = [];
            squareMeshes[faceName] = [];

            // Create 3x3 grid of squares
            for (let row = 0; row < 3; row++) {
                for (let col = 0; col < 3; col++) {
                    const index = row * 3 + col;
                    const square = createSquare(faceName, index);
                    
                    // Position squares in a 3x3 grid
                    square.position.set(
                        (col - 1) * 1,  // -1, 0, 1
                        (1 - row) * 1,  // 1, 0, -1
                        0.01
                    );
                    
                    faceGroup.add(square);
                    squareMeshes[faceName][index] = square;
                }
            }

            // Create face background
            const faceGeometry = new THREE.PlaneGeometry(3, 3);
            const faceMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x333333,
                transparent: true,
                opacity: 0.1
            });
            const faceMesh = new THREE.Mesh(faceGeometry, faceMaterial);
            faceMesh.userData = { type: 'face', faceName: faceName };
            faceGroup.add(faceMesh);
            faceMeshes[faceName] = faceMesh;

            return faceGroup;
        }

        function createSquare(faceName, index) {
            const geometry = new THREE.PlaneGeometry(0.9, 0.9);
            const material = new THREE.MeshBasicMaterial({ 
                color: 0xffffff,
                side: THREE.DoubleSide
            });
            const square = new THREE.Mesh(geometry, material);
            square.userData = { 
                type: 'square', 
                faceName: faceName, 
                index: index 
            };

            // Add number text to the square
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 128;
            const context = canvas.getContext('2d');
            
            // Clear canvas
            context.fillStyle = 'rgba(0,0,0,0)';
            context.fillRect(0, 0, 128, 128);
            
            // Draw number
            context.fillStyle = '#808080'; // Grey color (halfway between white and black)
            context.font = 'bold 60px Arial';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText((index + 1).toString(), 64, 64);
            
            // Create texture from canvas
            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            
            // Create text material
            const textMaterial = new THREE.MeshBasicMaterial({
                map: texture,
                transparent: true,
                side: THREE.DoubleSide
            });
            
            // Create text plane slightly in front of the square
            const textGeometry = new THREE.PlaneGeometry(0.8, 0.8);
            const textMesh = new THREE.Mesh(textGeometry, textMaterial);
            textMesh.position.z = 0.001; // Slightly in front
            
            square.add(textMesh);
            
            return square;
        }

        function updateSquareColor(faceName, index) {
            const square = squareMeshes[faceName][index];
            const isBlack = cubeState[faceName][index];
            square.material.color.setHex(isBlack ? 0x000000 : 0xffffff);
        }

        function toggleSquare(faceName, index) {
            cubeState[faceName][index] = !cubeState[faceName][index];
            updateSquareColor(faceName, index);
        }

        function getDiagonalSquares(faceName, index) {
            const row = Math.floor(index / 3);
            const col = index % 3;
            const diagonals = [];

            // Same face diagonals
            const directions = [
                [-1, -1], [-1, 1], [1, -1], [1, 1]
            ];

            directions.forEach(([dr, dc]) => {
                const newRow = row + dr;
                const newCol = col + dc;
                if (newRow >= 0 && newRow < 3 && newCol >= 0 && newCol < 3) {
                    diagonals.push({ faceName, index: newRow * 3 + newCol });
                }
            });

            // Cross-face diagonals
            const crossFaceDiagonals = getCrossFaceDiagonals(faceName, index);
            diagonals.push(...crossFaceDiagonals);

            return diagonals;
        }

        function getCrossFaceDiagonals(faceName, index) {
            const diagonals = [];
            const row = Math.floor(index / 3);
            const col = index % 3;
            
            // Convert 0-based index to 1-9 numbering for clarity
            const squareNumber = index + 1;
            
            // Scenario 1: Corner squares (1,3,7,9) - flip square 6 on adjacent faces
            if ([1, 3, 7, 9].includes(squareNumber)) {
                const cornerMappings = {
                    front: {
                        1: ['top', 'left'],     // square 1 affects top and left faces
                        3: ['top', 'right'],    // square 3 affects top and right faces  
                        7: ['bottom', 'left'],  // square 7 affects bottom and left faces
                        9: ['bottom', 'right']  // square 9 affects bottom and right faces
                    },
                    back: {
                        1: ['top', 'right'],    // square 1 affects top and right faces
                        3: ['top', 'left'],     // square 3 affects top and left faces
                        7: ['bottom', 'right'], // square 7 affects bottom and right faces
                        9: ['bottom', 'left']   // square 9 affects bottom and left faces
                    },
                    right: {
                        1: ['top', 'front'],    // square 1 affects top and front faces
                        3: ['top', 'back'],     // square 3 affects top and back faces
                        7: ['bottom', 'front'], // square 7 affects bottom and front faces
                        9: ['bottom', 'back']   // square 9 affects bottom and back faces
                    },
                    left: {
                        1: ['top', 'back'],     // square 1 affects top and back faces
                        3: ['top', 'front'],    // square 3 affects top and front faces
                        7: ['bottom', 'back'],  // square 7 affects bottom and back faces
                        9: ['bottom', 'front']  // square 9 affects bottom and front faces
                    },
                    top: {
                        1: ['back', 'left'],    // square 1 affects back and left faces
                        3: ['back', 'right'],   // square 3 affects back and right faces
                        7: ['front', 'left'],   // square 7 affects front and left faces
                        9: ['front', 'right']   // square 9 affects front and right faces
                    },
                    bottom: {
                        1: ['front', 'left'],   // square 1 affects front and left faces
                        3: ['front', 'right'],  // square 3 affects front and right faces
                        7: ['back', 'left'],    // square 7 affects back and left faces
                        9: ['back', 'right']    // square 9 affects back and right faces
                    }
                };

                if (cornerMappings[faceName] && cornerMappings[faceName][squareNumber]) {
                    cornerMappings[faceName][squareNumber].forEach(adjacentFace => {
                        diagonals.push({ faceName: adjacentFace, index: 5 }); // square 6 (index 5)
                    });
                }
            }
            
            // Scenario 2: Edge squares with specific flipping patterns
            else if ([2, 4, 6, 8].includes(squareNumber)) {
                const edgeMappings = {
                    front: {
                        2: { face: 'top', squares: [7, 9] },     // square 2 flips 7,9 on top face
                        4: { face: 'left', squares: [3, 9] },    // square 4 flips 3,9 on left face
                        6: { face: 'right', squares: [1, 7] },   // square 6 flips 1,7 on right face
                        8: { face: 'bottom', squares: [1, 3] }   // square 8 flips 1,3 on bottom face
                    },
                    back: {
                        2: { face: 'top', squares: [1, 3] },     // square 2 flips 1,3 on top face
                        4: { face: 'right', squares: [3, 9] },   // square 4 flips 3,9 on right face
                        6: { face: 'left', squares: [1, 7] },    // square 6 flips 1,7 on left face
                        8: { face: 'bottom', squares: [7, 9] }   // square 8 flips 7,9 on bottom face
                    },
                    right: {
                        2: { face: 'top', squares: [3, 9] },     // square 2 flips 3,9 on top face
                        4: { face: 'front', squares: [3, 9] },   // square 4 flips 3,9 on front face
                        6: { face: 'back', squares: [1, 7] },    // square 6 flips 1,7 on back face
                        8: { face: 'bottom', squares: [3, 9] }   // square 8 flips 3,9 on bottom face
                    },
                    left: {
                        2: { face: 'top', squares: [1, 7] },     // square 2 flips 1,7 on top face
                        4: { face: 'back', squares: [3, 9] },    // square 4 flips 3,9 on back face
                        6: { face: 'front', squares: [1, 7] },   // square 6 flips 1,7 on front face
                        8: { face: 'bottom', squares: [1, 7] }   // square 8 flips 1,7 on bottom face
                    },
                    top: {
                        2: { face: 'back', squares: [1, 3] },    // square 2 flips 1,3 on back face
                        4: { face: 'left', squares: [1, 3] },    // square 4 flips 1,3 on left face
                        6: { face: 'right', squares: [1, 3] },   // square 6 flips 1,3 on right face
                        8: { face: 'front', squares: [1, 3] }    // square 8 flips 1,3 on front face
                    },
                    bottom: {
                        2: { face: 'front', squares: [7, 9] },   // square 2 flips 7,9 on front face
                        4: { face: 'left', squares: [7, 9] },    // square 4 flips 7,9 on left face
                        6: { face: 'right', squares: [7, 9] },   // square 6 flips 7,9 on right face
                        8: { face: 'back', squares: [7, 9] }     // square 8 flips 7,9 on back face
                    }
                };

                if (edgeMappings[faceName] && edgeMappings[faceName][squareNumber]) {
                    const mapping = edgeMappings[faceName][squareNumber];
                    mapping.squares.forEach(square => {
                        diagonals.push({ faceName: mapping.face, index: square - 1 }); // Convert to 0-based index
                    });
                }
            }

            return diagonals;
        }

        function onMouseDown(event) {
            isDragging = true;
            previousMousePosition.x = event.clientX;
            previousMousePosition.y = event.clientY;
        }

        function onMouseMove(event) {
            if (isDragging) {
                const deltaMove = {
                    x: event.clientX - previousMousePosition.x,
                    y: event.clientY - previousMousePosition.y
                };

                cube.rotation.y += deltaMove.x * 0.01;
                cube.rotation.x += deltaMove.y * 0.01;

                previousMousePosition.x = event.clientX;
                previousMousePosition.y = event.clientY;
            }
        }

        function onMouseUp() {
            isDragging = false;
        }

        function onMouseClick(event) {
            if (isDragging) return;

            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            
            // Get all square meshes for intersection
            const allSquares = [];
            faceNames.forEach(faceName => {
                squareMeshes[faceName].forEach(square => {
                    allSquares.push(square);
                });
            });

            const intersects = raycaster.intersectObjects(allSquares);

            if (intersects.length > 0) {
                const clickedSquare = intersects[0].object;
                const { faceName, index } = clickedSquare.userData;
                
                // Toggle clicked square
                toggleSquare(faceName, index);
                
                // Toggle diagonal squares
                const diagonals = getDiagonalSquares(faceName, index);
                diagonals.forEach(diagonal => {
                    toggleSquare(diagonal.faceName, diagonal.index);
                });
            }
        }

        function resetCube() {
            // Reset all cube states to white (false)
            faceNames.forEach(faceName => {
                for (let i = 0; i < 9; i++) {
                    cubeState[faceName][i] = false;
                    updateSquareColor(faceName, i);
                }
            });
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        // Initialize the game
        init();
    </script>
</body>
</html>
